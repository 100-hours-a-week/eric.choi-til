# DB index

- 트리
    - 정의 : 노드로 이루어진 자료구조. 계층적인 데이터 구조. 부모-자식 관계를 가지는 노드로 구성
- BST
    - 이진 탐색 트리
    - 속성 :
        - 각 노드에 값이 존재
        - 값들은 정렬된 순서가 있음. 키 값이 총순서를 가짐
        - 왼쪽 서브트리는 작은 값. 오른쪽 서브트리는 큰 값
        - 좌우 하위 트리는 각각 다시 이진 트리
    - 문제점 :
        - 균형이 깨질 수 있음. 편향 트리 생길 수 있음. 이러면 트리 쓰는 이유가 없어짐. 단일 연결 리스트가 되니까.
- B-트리
    - 효율적인 데이터 검색을 위해 사용.
    - 여러 자식 노드 가질 수 있음. 높이를 균형 있게 유지함
    - 차수에 따라 자식 노드 개수 설정.
    - 노드의 키에 따라서 정렬됨.
    
    ![image.png](attachment:e42ea368-0d30-4736-b971-a353803822ac:image.png)
    

- B+트리
    - 모든 레코드가 리프 노드에 정렬되어 있음. 키만 내부 블록에 저장됨.
    - 리프노드가 아닌 노드는 인덱스 역할만 할 수 있음.
    - 리프노드끼리는 linked-list로 연결되어 있음
    
    ![image.png](attachment:0b781da3-e4a0-420c-ba8f-1d116104dc61:image.png)
    

- index
    - 정의 : 테이블 조회 동작 속도 높여주는 자료 구조
    - 클러스터형 인덱스 / 비클러스터형 인덱스 로 나뉨
        - 클러스터형 인덱스 : 데이터가 인덱스 순서대로 물리적으로 정렬되어 저장되는 인덱스
            - 특징 :
                - 단일성
                - 물리적 정렬
                - 자동 생성
                - 인덱스 구조
        - 비클러스터형 인덱스 : 인덱스와 데이터가 분리되어있어 인덱스는 데이터 위치를 가리키는 포인터만 포함되어 있음.
            - 특징 :
                - 다중성
                - 논리적 정렬
                - 공간 요구
            - 비클러스터형 인덱스는 B-tree 또는 B+tree와 같은 구조로 구현됨. 각 인덱스 페이지는 트리의 노드처럼 동작
    - 알아야 하는 이유 :
        - 빠르게 정렬된 결과를 출력할 수 있기 때문에
        - 단점도 있음 :
            - 실제 컬럼이 삭제, 수정되면 인덱스도 해줘야됨
            - LIKE %검색어 일 때는 %검색어 때문에 인덱스 사용 불가능
    - 동작 방식 :
        1. 생성
        2. 검색 최적화
        3. 유지관리
        4. 삭제

---

# 카디널리티

- 열(칼럼)의 카디널리티 : 특정 칼럼에 포함될 수 있는 고유한 값의 수를 나타냄
    - 높은 카디널리티: 많은 고유 값이 있음 (예: 주민등록번호, 이메일 주소)
    - 낮은 카디널리티: 적은 고유 값이 있음 (예: 성별, 혈액형)

- 관계의 카디널리티 : 두 엔티티 간의 관계에서 한 엔티티가 다른 엔티티와 맺을 수 있는 관계의 수량적 특성
    - 일대일(1:1): 각 엔티티는 상대 엔티티와 하나의 관계만 가짐
    - 일대다(1:N): 하나의 엔티티가 여러 상대 엔티티와 관계를 가짐
    - 다대다(N:M): 양쪽 엔티티 모두 여러 상대 엔티티와 관계를 가짐

---

# Transaction

- 정의 : DB의 상태를 변경시키는 작업의 단위. 한꺼번에 수행되어야 할 연산을 모아놓은 것.
- 상태
    - active : 실행 중
    - partially committed : 명령 성공적으로 완료.
    - aborted : 트랜잭션 취소 상태
    - faild : 실패 상태
    - committed : DB에 영구적으로 반영된 상태
- 사용 이유 : 데이터베이스의 무결성과 일관성을 보장하고, 여러 작업을 하나의 논리적인 작업 단위로 묶어서 처리하기 위해서
- 트랜잭션 4가지 특징 ACID :
    - Atomicity : 원자성. 전부 수행되거나 전부 수행되지 않거나
    - Consistenty : 정합성. 시슽템이 가지고 있는 고정 요소는 수행 전과 후의 상태가 같아야 함
    - Isolation : 다수의 트랜잭션이 병행 실행될 때, 다른 트랜잭션 연산에 끼어들 수 없음
    - Durability : 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 함
- Isolation level :
    - 트랜잭션 독립의 정도.
    - read uncommitted
        
        트랜잭션이 아직 확정되지 않은 데이터를 다른 트랜잭션에서 조회할 수 있음.
        
        격리 수준이 가장 낮으며 성능은 좋지만 데이터 무결성이 보장되지 않음.
        
        발생할 수 있는 문제:
        
        - dirty read: 다른 트랜잭션에서 변경한 데이터가 롤백될 경우 잘못된 데이터를 읽을 가능성이 있음.
        - non-repeatable read: 같은 데이터를 여러 번 조회할 때 값이 달라질 수 있음.
        - phantom read: 새로운 데이터가 삽입되어 동일한 조회 결과가 달라질 수 있음.
    - read committed
        
        커밋이 완료된 데이터만 읽을 수 있도록 보장됨.
        
        dirty read를 방지하지만 동일 트랜잭션 내에서 데이터가 변경될 가능성이 있음.
        
        발생할 수 있는 문제:
        
        - non-repeatable read: 같은 데이터를 다시 읽을 때 값이 달라질 수 있음.
        - phantom read: 다른 트랜잭션에서 삽입한 데이터가 조회될 가능성이 있음.
    - repeatable read
        
        동일한 트랜잭션 내에서는 동일한 데이터 조회 결과를 보장함.
        
        non-repeatable read를 방지하지만 phantom read는 발생할 수 있음.
        
        발생할 수 있는 문제:
        
        - phantom read: 동일한 조건으로 여러 번 조회할 때 새로운 데이터가 추가될 가능성이 있음.
    - serializable
        
        트랜잭션 간 완전한 격리를 유지하여 모든 이상 현상을 방지함.
        
        가장 강력한 격리 수준으로 동시 실행을 최소화하여 데이터 일관성을 유지하지만 성능 저하가 크고 병렬 처리가 어려울 수 있음.
        
        발생할 수 있는 문제:
        
        - 없음 (모든 데이터 일관성 문제 해결)

---

# NoSQL

- 정의 : Not only SQL, SQL만을 사용하지 않는 여러 유형의 데이터베이스
- 알아야하는 이유 :
    - 대규모 데이터 처리 : 분산 저장을 통해 병렬 데이터 처리 가능
    - 데이터의 다양성 : 구조적 데이터, 반구조적 데이터(JSON, XML), 비구조적 데이터(이미지, 동영상)를 유연하게 처리 가능
    - 수평적 확장성 : 기존 RDBMS의 수직 확장 대비 비용 효율성이 높음
    - 유연한 설계 및 개발 속도
- 동작 방식 :
    - 데이터 구조에 따라 키-값, 문서, 컬럼 기반, 그래프 등으로 구분되며, 각 구조에 맞게 데이터를 저장, 조회, 분산 처리
        - 키-값 저장소 : 각 키에 하나의 값이 매핑되는 가장 단순한 형태의 데이터 저장 방식. 메모리
            - 동작 방식 :
                - 쓰기: 키를 해싱하여 데이터 저장 위치 결정.
                - 읽기: 키를 입력받아 데이터를 검색.
                - 샤딩: 해시 함수를 사용해 데이터를 여러 노드에 분산 저장.
            - 장점 :
                - 빠른 읽기 쓰기
                - 간단한 구조
            - 단점 :
                - 복잡한 데이터 처리 어려움
            - Redis
        - 문서 지향 데이터베이스 : JSON, XML과 같은 반정형 문서 형식을 사용하여 데이터를 저장
            - 동작방식 :
                - 쓰기: 고유 ID로 문서를 저장.
                - 읽기: ID 또는 특정 조건(필드 값)을 기준으로 문서를 검색.
                - 인덱스: 특정 필드에 대해 인덱스를 생성하여 조회 속도를 최적화.
            - 장점 : 유연한 스키마, 복잡한 모델링
            - 단점 : 데이터 간 관계성 약함
            - MongoDB
        - 컬럼 기반 데이터베이스 : 컬럼 단위로 데이터를 저장하고 관리하여, 대량의 데이터를 빠르게 조회하고 분석
            - 동작 방식 :
                - 쓰기: RowKey와 Column 기준으로 데이터를 저장.
                - 읽기: 특정 RowKey 또는 Column 기반으로 데이터 검색.
                - 샤딩: RowKey를 기준으로 데이터 분산.
            - 장점 :
                - 대규모 데이터 분석과 빠른 처리
                - 쓰기 속도 빠름
            - 단점 :
                - select 느림
            - Cassandra
        - 그래프 데이터베이스 : 데이터를 노드와 엣지로 표현하여, 객체 간의 관계를 중심으로 데이터를 저장하고 조회
            - 동작 방식 :
                - 쓰기: 데이터는 노드와 간선으로 저장.
                - 읽기: 노드와 관계를 탐색.
                - 인덱스: 노드 및 간선에 대한 인덱스를 생성하여 탐색 속도 향상.
            - 장점 :
                - 복잡한 데이터 관계 효율적으로 탐색
            - 단점 :
                - 대규모 데이터 처리 시 성능 저하 가능
                - 트랜잭션 처리량 많으면 성능 저하
            - Neo4j

---

# Eventual Consistency

- 정의 : 분산 시스템에서 중요한 데이터 일관성 모델 중 하나
- NoSQL 데이터베이스는 대규모 데이터 처리와 수평적 확장을 지원하기 위해 실시간 일관성을 포기하고, 일정 시간이 지나면 데이터 일관성이 보장되는 Eventual Consistency 모델을 채택
- 대신 이로 인해 개발자는 데이터 무결성을 직접 관리해야 할 필요가 있으며, 이를 위해 낙관적 동시성 제어(OCC) 같은 기법을 사용

---

# CAP 이론

- 정의 :  분산 데이터베이스 시스템이 동시에 제공할 수 있는 3가지 특성 중 최대 두 가지만 보장함
    - 분산 데이터베이스 시스템은 분할이 생겼을 때 일관성과 가용성 중 하나를 희생해야 한다는 것을 의미
- 3가지 특성
    - 일관성 : 모든 노드는 동시에 같은 데이터를 볼 수 있어야 함. 즉 항상 가장 최근에 기록된 데이터를 반환해야 함
    - 가용성 : 모든 요청은 성공 또는 실패 응답을 받아야 함. 즉 일부가 실패해도 계속 작동해야 함
    - 분할 내성 : 네트워크 노드 간 통신 실패(분할)가 발생하더라도 시스템은 계속 작동해야 함

---

# 객체지향 4대요소

1. 캡슐화(Encapsulation)

- 정의: 객체의 데이터와 메서드를 하나로 묶고 외부에서의 접근을 제한함
- 사용 이유:
    - 정보 은닉을 통한 데이터 보호
    - 코드 유지보수성 향상
    - 객체 내부 구현 변경에 따른 외부 영향 최소화
- 사용 방법(Java):
    - private, protected, public 접근 제어자 활용
    - 일반적으로 필드는 private으로 선언하고 필요한 경우에만 getter/setter 제공
    - 무분별한 setter 사용은 지양하고 객체의 일관성을 유지하는 방식으로 설계

2. 상속(Inheritance)

- 정의: 기존 클래스의 속성과 동작을 물려받아 새로운 클래스를 만드는 것
- 사용 이유:
    - 코드 재사용성 증가
    - 체계적인 클래스 구조 형성
    - 유지보수성 향상
- 사용 방법(Java):
    - extends 키워드를 사용하여 구현
    - 다중 상속은 지원하지 않음(한 클래스는 하나의 부모 클래스만 상속 가능)

3. 다형성(Polymorphism)

- 정의: 하나의 인터페이스나 부모 클래스를 통해 여러 형태의 객체를 다룰 수 있는 능력
- 사용 이유:
    - 코드 유연성 확보
    - 확장성 향상
    - 객체 간 결합도 감소
- 사용 방법(Java):
    - 메서드 오버라이딩: 자식 클래스에서 부모 클래스의 메서드 재정의
    - 인터페이스 구현: 동일한 인터페이스를 다양한 클래스가 구현

4. 추상화(Abstraction)

- 정의: 불필요한 세부사항을 숨기고 핵심 개념만 표현하여 복잡성을 관리하는 것
- 사용 이유:
    - 복잡성 감소
    - 인터페이스와 구현의 분리
    - 코드 변경 용이성 확보
- 사용 방법(Java):
    - 추상 클래스:
        - 공통된 필드(변수)와 구현된 메서드를 가질 수 있음
        - extends 키워드로 하나의 부모 클래스만 상속 가능
        - 생성자 정의 가능
        - 일부 메서드는 구현하고 일부는 추상 메서드로 남길 수 있음
    - 인터페이스:
        - 원칙적으로 메서드 선언과 상수만 포함 가능
        - implements 키워드로 여러 인터페이스 동시 구현 가능
        - 생성자 정의 불가
        - Java 8 이후 default 및 static 메서드로 일부 구현 가능하지만, 상태(필드)는 가질 수 없음

---

## B-Tree와 B+Tree의 차이점

### B-Tree

- **구조**: 모든 노드(내부 노드와 리프 노드)에 키와 데이터를 저장
- **검색**: 트리의 어느 레벨에서든 데이터를 찾을 수 있음
- **메모리 효율성**: 상대적으로 낮음(각 노드에 데이터 저장)
- **범위 검색**: 비효율적(인접 데이터가 다른 노드에 흩어져 있을 수 있음)
- **사용 사례**: 디스크 기반 데이터베이스, 파일 시스템(NTFS, HFS), 메모리 사용이 제한적이지 않은 환경

### B+Tree

- **구조**: 내부 노드에는 키만 저장, 모든 데이터는 리프 노드에만 저장
- **검색**: 항상 리프 노드까지 탐색해야 함
- **메모리 효율성**: 상대적으로 높음(내부 노드에는 키만 저장하므로 더 많은 키를 저장 가능)
- **범위 검색**: 효율적(리프 노드가 연결 리스트로 연결되어 있음)
- **사용 사례**: RDBMS(MySQL의 InnoDB, PostgreSQL, Oracle), 범위 검색이 빈번한 애플리케이션

## 카디널리티가 낮은 컬럼의 인덱스 비효율성

카디널리티가 낮은 컬럼(예: 성별, 상태 코드)에 인덱스를 생성하는 것이
비효율적인 이유:

1. **선택성(Selectivity) 저하**:
    - 카디널리티가 낮으면 인덱스의 선택성이 낮아짐
    - 예: 성별 컬럼에서 '남성'으로 검색하면 전체 데이터의 약 50%가 반환됨
2. **인덱스 스캔 후 테이블 액세스 비용 증가**:
    - 많은 레코드를 찾은 후 각각에 대해 테이블에 접근해야 함
    - 이 비용이 전체 테이블 스캔보다 더 커질 수 있음
3. **인덱스 유지 비용**:
    - 데이터 변경 시 인덱스도 업데이트해야 함
    - 성능 향상보다 유지 비용이 더 큰 경우가 많음
4. **쿼리 옵티마이저의 잘못된 선택**:
    - 옵티마이저가 인덱스의 효용성을 과대평가하여 비효율적인 실행 계획을 선택할 수 있음

## 커버링 인덱스의 성능 향상 이유

커버링 인덱스(Covering Index)는 쿼리에서 필요한 모든 컬럼이 인덱스에 포함되어 있어 테이블 접근 없이 인덱스만으로 쿼리를 처리할 수 있는 경우

성능 향상 이유:

1. **테이블 액세스 회피**:
    - 인덱스만으로 쿼리를 해결하므로 데이터 페이지 접근이 필요 없음
    - I/O 비용 크게 감소
2. **메모리 효율성**:
    - 인덱스는 일반적으로 데이터보다 크기가 작아 메모리에 더 많이 캐싱될 수 있음
3. **인덱스 구조의 효율성**:
    - 인덱스는 정렬되어 있어 범위 검색이 효율적
    - 필요한 데이터만 컴팩트하게 저장되어 있음
4. **랜덤 I/O 감소**:
    - 인덱스 리프 노드만 순차적으로 스캔하므로 랜덤 I/O 발생 없음

## 트랜잭션 격리 수준별 발생 가능한 문제

### 1. Read Uncommitted (가장 낮은 격리 수준)

- **발생 문제**:
    - Dirty Read: 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있음
    - Non-repeatable Read: 한 트랜잭션 내에서 같은 쿼리를 실행했을 때 다른 결과가 나올 수 있음
    - Phantom Read: 한 트랜잭션 내에서 같은 쿼리를 실행했을 때 이전에 없던 레코드가 나타날 수 있음

### 2. Read Committed

- **발생 문제**:
    - Non-repeatable Read: 다른 트랜잭션이 데이터를 변경하고 커밋하면, 같은 쿼리의 결과가 달라질 수 있음
    - Phantom Read: 다른 트랜잭션이 새 레코드를 삽입하면, 같은 쿼리가 이전에 없던 레코드를 반환할 수 있음

### 3. Repeatable Read

- **발생 문제**:
    - Phantom Read: 대부분의 DBMS에서 발생 가능(MySQL InnoDB는 MVCC로 이 문제도 방지)

### 4. Serializable (가장 높은 격리 수준)

- **발생 문제**: 없음
- **단점**: 동시성 저하, 교착 상태(deadlock) 가능성 증가

## 분산 시스템에서 ACID 보장의 어려움

ACID(원자성, 일관성, 고립성, 지속성)를 분산 시스템에서 보장하기 어려운 이유:

1. **네트워크 분할(Network Partitioning)**:
    - 노드 간 통신 실패로 일부 노드가 격리될 수 있음
    - 이 상태에서 원자성과 일관성을 유지하기 어려움
2. **분산 트랜잭션의 복잡성**:
    - 2PC(Two-Phase Commit) 같은 프로토콜 필요
    - 참여 노드 수가 많을수록 성능 저하 심화
    - 코디네이터 실패 시 시스템이 블로킹될 수 있음
3. **지연 시간(Latency)**:
    - 노드 간 통신에 지연 발생
    - 트랜잭션 완료 시간 증가, 처리량 감소
4. **일관된 시간 개념 부재**:
    - 분산 환경에서 정확한 글로벌 시간 개념 구현 어려움
    - 이벤트 순서 결정 및 일관성 유지에 영향
5. **확장성 제약**:
    - 강한 일관성은 확장성을 제한
    - 노드 수 증가에 따라 일관성 유지 비용 급증

## CAP 이론의 Consistency와 Availability 트레이드오프

CAP 이론에 따르면 분산 시스템은 Consistency(일관성), Availability(가용성), Partition Tolerance(분할 내성) 중 동시에 세 가지를 모두 만족할 수 없음

### 일관성(C)과 가용성(A) 트레이드오프 예시:

1. **은행 시스템(CP 선택)**:
    - 계좌 잔액 정보는 항상 정확해야 함
    - 네트워크 분할 발생 시, 일관성을 위해 일부 노드에서 서비스 거부(가용성 희생)
    - 예: 두 지점 간 연결이 끊기면, 잔액 불일치 방지를 위해 한쪽에서 거래 중단
2. **소셜 미디어(AP 선택)**:
    - 사용자는 항상 서비스에 접근할 수 있어야 함
    - 네트워크 분할 발생 시, 가용성을 위해 일시적 데이터 불일치 허용
    - 예: 페이스북에서 한 데이터 센터가 분리되어도 사용자는 계속 포스팅 가능, 나중에 동기화
3. **전자상거래(CA와 CP 혼합)**:
    - 상품 재고는 일관성 중시(CP)
    - 제품 카탈로그 및 리뷰는 가용성 중시(AP)
    - 예: 주문 처리 시스템은 네트워크 문제 발생 시 일시 중단될 수 있으나, 상품 탐색은 계속 가능

## Eventual Consistency와 데이터 충돌 해결

Eventual Consistency(최종 일관성)는 일시적으로 데이터 불일치를 허용하지만, 일정 시간이 지나면 모든 복제본이 일관된 상태가 되는 모델

### 데이터 충돌 해결 방법:

1. **Last-Writer-Wins(타임스탬프 기반)**:
    - 각 업데이트에 타임스탬프 부여
    - 가장 최근 타임스탬프를 가진 업데이트가 승리
    - 예: Amazon DynamoDB의 기본 충돌 해결 방식
2. **벡터 시계(Vector Clocks)**:
    - 각 노드의 작업 순서를 추적하는 벡터 사용
    - 인과 관계(causal relationship) 파악 가능
    - 예: Riak, Cassandra의 충돌 감지
3. **충돌 회피 전략**:
    - 특정 키의 모든 쓰기 작업을 같은 노드로 라우팅
    - 예: 일관된 해싱(Consistent Hashing)
4. **애플리케이션 수준 해결**:
    - 충돌을 감지하고 비즈니스 로직에 따라 해결
    - 예: 쇼핑 카트 병합 (두 버전의 카트 아이템 통합)
5. **CRDTs(Conflict-free Replicated Data Types)**:
    - 수학적으로 충돌 없는 데이터 구조 사용
    - 예: 카운터, 집합 등의 특수 데이터 타입
    - Redis Enterprise, Riak에서 사용

## MongoDB와 RDBMS의 스키마 설계 차이점

### MongoDB (Document DB)

- **스키마 유연성**:
    - 스키마 없음(Schemaless) 또는 유연한 스키마
    - 같은 컬렉션 내 문서들이 다른 필드 구조를 가질 수 있음
    - 런타임에 스키마 변경 가능
- **데이터 모델링**:
    - 임베디드 문서(중첩 구조)를 통한 비정규화 선호
    - 관련 데이터를 단일 문서에 저장하여 조인 최소화
    - 예: 사용자와 주소를 별도 테이블이 아닌 하나의 문서로 저장
- **관계 처리**:
    - 참조(Reference) 또는 임베딩(Embedding)으로 관계 표현
    - 트랜잭션 지원은 제한적(최신 버전에서 개선됨)
- **최적화 접근**:
    - 읽기 패턴에 맞춘 데이터 구조 설계
    - 중복 데이터 허용을 통한 성능 최적화

### RDBMS

- **스키마 정의**:
    - 엄격한 스키마 정의 필요
    - 테이블 구조 변경은 ALTER TABLE 명령 필요
    - 데이터 타입, 제약조건 명시적 정의
- **데이터 모델링**:
    - 정규화를 통한 데이터 중복 최소화
    - 관계형 모델(ER 다이어그램) 기반 설계
    - 예: 사용자와 주소를 별도 테이블로 저장하고 외래 키로 연결
- **관계 처리**:
    - 외래 키 제약조건으로 관계 강제
    - JOIN을 통한 데이터 조합
    - 완전한 ACID 트랜잭션 지원
- **최적화 접근**:
    - 정규화와 인덱싱을 통한 최적화
    - 필요한 경우 제한적인 비정규화
