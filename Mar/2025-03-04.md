# Database

- 정의 : 자료를 활용하려고 구조화한 데이터 모음
- 사용 이유 : 테이블로 저장하여 데이터 안정성과 신뢰성 보장
- RDB : 관계형 데이터베이스. 상호 연관된 데이터를 저장하는 DB
    - 기본키와 외래키를 이용한 관계 맺기
- TIMESTAMP : row 생성, 삭제 등 시간을 나타내는데 사용
- DATETIME : 비즈니스 로직 시간에 사용
- 사용 방법 : DBMS를 이용하여 특정 규칙에 따라 데이터를 입력, 업데이트, 조회하는 SQL을 통해 사용
- DBMS : 데이터베이스 관리 프로그램
- 일관성과 무결성의 차이
    - 일관성 : 데이터의 올바른 유무와 상관없이 데이터들의 값이 서로 일치하는 상태
    - 무결성 : 데이터 값이 정확한 상태

- key의 종류
    - 후보키 : 튜플을 유일하게 식별할 수 있는 속성들의 부분 집합
    - 기본키 : 특정 튜플을 유일하게 구별할 수 있는 속성. NULL값 안됨
    - 대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
    - 슈퍼키 : 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키. 유일성은 만족, 최소성은 x
    - 외래키 : 관계를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성

---

# RDBMS

- 정의 : 관계형 데이터베이스 관리 시스템으로, 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스. RDBMS는 테이블이라는 최소 단위로 구성이 되며, 테이블은 하나 이상의 열과 행으로 이루어져 있음

---

# 정규화 / 역정규화

정규화

- 정의 : 관계형 데이터베이스의 설계에서 데이터 중복을 줄이고 데이터 무결성을 개선하기 위해 데이터를 정규형에 맞도록 구조화하는 프로세스
- 사용 이유 : 무결성 유지, 저장 용량 감소
- 이상 현상 : 설계 문제로 발생하는 문제점
    - 삽입 이상 : 데이터 삽입 때 원하지 않는 데이터까지 입력해야 하는 경우
    - 삭제 이상 : 데이터 삭제 때, 관련 정보가 함께 삭제되는 경우
    - 갱신 이상 : 데이터 중복으로 갱신할 때 일관성 없어지는 경우
- 사용 방법 :
    - 제 1 정규형 : 원자값 갖도록 분해
    - 제 2 정규형 : 완점 함수 종속 만족. 기본키의 부분 집합에 의존하는 칼럼들 분리
    - 제 3 정규형 : 이행적 함수 종속 제거

역정규화

- 정의 : 역정규화는 성능 최적화를 위해 정규화를 일부 되돌려 데이터 중복을 허용하는 과정. 데이터베이스 조회 성능을 향상시키기 위해 사용

- 사용 이유 : 조인(Join) 연산 최소화, 조회 속도 향상

- 사용 방법 :
    - 중복 데이터 추가
    - 테이블 병합
    - 중간 테이블
    - 비정규형 데이터 저장

함수 종속성

- 정의 : 데이터베이스에서 한 속성의 값이 다른 속성의 값에 의해 결정되는 관계를 의미

- 종류 :
    
    (1) 완전 함수 종속 (Full Functional Dependency)
    
    - 기본키의 일부가 아닌 전체를 이용해야만 결정되는 종속 관계
    - 예시: (학번, 과목코드) → 성적
        - 학번과 과목코드 둘 다 필요해야 성적이 결정됨
    
    (2) 부분 함수 종속 (Partial Functional Dependency)
    
    - 기본키의 일부만으로도 결정될 수 있는 종속 관계
    - 예시: (학번, 과목코드) → 학과
        - 학번 하나만으로도 학과가 결정되므로 부분 함수 종속
    
    (3) 이행적 함수 종속 (Transitive Functional Dependency)
    
    - X → Y, Y → Z이면, X → Z도 성립하는 경우
    - 예시: 학번 → 학과, 학과 → 학과장
        - 학번이 학과를 결정하고, 학과가 학과장을 결정하므로학번 → 학과장도 성립 (이행적 종속)
    
    (4) 다치 종속 (Multivalued Dependency, MVD)
    
    - X가 Y와 Z를 각각 독립적으로 결정하는 경우 (즉, Y와 Z가 서로 종속되지 않음)
    - 예시: (학생, 동아리, 취미) 관계에서
        - 학생 →→ 동아리
        - 학생 →→ 취미
        - 하지만 동아리와 취미는 서로 직접적인 관계가 없음

---

# JOIN

- 정의 : 두 개 이상의 테이블을 결합하여 데이터를 조회하는 SQL 연산

- 종류
    - INNER JOIN (내부 조인)
        - 두 테이블에서 일치하는 데이터만 반환
        - 조건에 맞지 않는 데이터는 제외됨
        
        ```java
        SELECT 학생.이름, 수강.과목
        FROM 학생
        INNER JOIN 수강 ON 학생.학번 = 수강.학번;
        ```
        
    - LEFT JOIN (왼쪽 외부 조인)
        - 왼쪽 테이블의 모든 데이터를 가져오고, 오른쪽 테이블에 매칭되는 값이 없으면 `NULL` 반환
        
        ```java
        SELECT 학생.이름, 수강.과목
        FROM 학생
        LEFT JOIN 수강 ON 학생.학번 = 수강.학번;
        ```
        
    - RIGHT JOIN (오른쪽 외부 조인)
        - 오른쪽 테이블의 모든 데이터를 가져오고, 왼쪽 테이블에 매칭되는 값이 없으면 `NULL` 반환
        
        ```java
        SELECT 학생.이름, 수강.과목
        FROM 학생
        RIGHT JOIN 수강 ON 학생.학번 = 수강.학번;
        ```
        
    - FULL OUTER JOIN (완전 외부 조인)
        - 양쪽 테이블의 모든 데이터를 포함하며, 매칭되지 않는 데이터는 `NULL`로 표시됨
        
        ```java
        SELECT 학생.이름, 수강.과목
        FROM 학생
        FULL OUTER JOIN 수강 ON 학생.학번 = 수강.학번;
        ```
        
    - CROSS JOIN (교차 조인)
        - 두 테이블의 모든 행을 곱집합(Cartesian Product) 형태로 조인
        - 조건 없이 모든 경우의 수를 가져옴
        
        ```java
        SELECT 학생.이름, 과목.과목명
        FROM 학생
        CROSS JOIN 과목;
        ```
        
    - SELF JOIN (자기 자신과 조인)
        - 같은 테이블을 두 번 사용하여 자기 자신과 조인하는 방식
        
        ```java
        SELECT A.이름 AS 직원1, B.이름 AS 직원2, A.부서
        FROM 직원 A
        JOIN 직원 B ON A.부서 = B.부서 AND A.이름 <> B.이름;
        ```
        

- Join 사용시 주의해야할 점
    - 조인 조건 명확히 설정 : 잘못된 조건을 사용하면 Cartesian Product가 발생해 성능 저하
    - 조인 순서 확인하기 : JOIN 순서에 따라 성능 차이가 발생할 수 있음.
    - 필요없는 조인은 피하기

---

# View

- 정의 : 하나 이상의 테이블에서 가상 테이블을 생성하는 객체
- 실제 데이터 저장 x, 가상의 테이블
- 사용 이유 : 데이터 조회 빠르게, 재사용, 유지보수
- Materialized View
    - 정의 : 일반 VIEW와 달리, 결과 데이터를 물리적으로 저장하는 뷰. 스냅샷 이라고도 함
    - 성능 최적화를 위해 사용됨 (특히, 복잡한 쿼리를 자주 실행할 때)
    - 일정 주기마다 데이터를 갱신해야 최신 데이터를 반영
    
    ```java
    CREATE MATERIALIZED VIEW 학생_수강정보_MV
    AS SELECT 학생.이름, 수강.과목
    FROM 학생
    JOIN 수강 ON 학생.학번 = 수강.학번;
    
    -- 수동 갱신
    REFRESH MATERIALIZED VIEW 학생_수강정보_MV;
    ```
    

# Union

- 정의 : 두 SQL 쿼리문의 결과를 합치는 연산자

```java
SELECT 이름, 학번 FROM 학생_2024
UNION
SELECT 이름, 학번 FROM 학생_2023;
```

- 사용시 성능 저하 케이스
    - UNION 대신 UNION ALL을 사용해야 할 때 :
        - `UNION`은 중복을 제거하기 위해 정렬(SORT) 작업을 수행 → 비용이 증가
        - 중복이 문제가 되지 않는 경우, `UNION ALL`을 사용하면 성능이 개선됨
    - 인덱스가 없을 때 :
        - `UNION`을 수행할 때, 각 `SELECT` 문이 개별적으로 실행되므로 적절한 인덱스가 없으면 성능 저하
        - 특히, WHERE 조건과 결합 키 컬럼에 인덱스를 설정해야 빠른 결과 조회 가능
    
    - 서브쿼리를 사용한 UNION :
        - 서브쿼리를 사용하면 임시 테이블이 생성될 수 있어 성능이 저하될 수 있음
        - 불필요한 서브쿼리를 제거하고 단순 SELECT + UNION 구조로 최적화 가능

---

# ERD

- 정의 : 데이터베이스를 설계할 때 개체(Entity), 속성(Attribute), 관계(Relationship)를 시각적으로 표현한 다이어그램

- 개체
    - 데이터베이스에서 관리할 대상
    - 사각형으로 표현
    - 서로 구별할 수 있는 인스턴스를 가짐

- 속성
    - 개체가 가지는 특징, 정보
    - 타원형으로 표현
    - 기본키, 후보키, 외래키 등이 존재

- 관계
    - 개체 간의 연관성
    - 마름모로 표현
    - 1:1, 1:N, M:N

- 관계 유형
    - 1:1 관계 :
        - 한 엔티티의 인스턴스가 다른 엔티티의 하나의 인스턴스와만 연결됨
    - 1:N 관계 :
        - 한 엔티티의 인스턴스가 다른 엔티티의 여러 개 인스턴스와 연결됨
    - M:N 관계 :
        - 한 개의 엔티티 인스턴스가 여러 개의 다른 엔티티 인스턴스와 관계를 맺을 수 있으며, 반대 방향도 동일
        - 하지만 관계를 직접 표현할 수 없으므로 중간 엔티티(수강신청)를 추가하여 1:N, N:1 관계로 변환함

---

관계형 데이터 베이스의 핵심 특징을 설명해주세요

복합키 사용하는 상황을 예시로 들어 설명해주세요

INNER JOIN과 LEFT JOIN의 차이를 예시로 설명해주세요
Materialized View와 일반 뷰의 차이점에 대해서 설명해주세요.

(특정 상황 제시 후) VARCHAR와 CHAR 중 어떤것을 선택해야하나요?

DATETIME과 TIMESTAMP의 차이점에 대해서 설명해주세요.

GROUP BY와 HAVING의 차이점을 설명해주세요.

<aside>
💡

## **1. 관계형 데이터베이스의 핵심 특징**

관계형 데이터베이스(Relational Database, RDBMS)는 데이터를 **테이블(표) 형식**으로 저장하고, **관계를 설정하여** 관리하는 데이터베이스다.

### **📌 주요 특징**

1. **테이블 구조**
    - 데이터를 **행(Row)과 열(Column)으로 구성된 테이블 형태로 저장**
    - 각 테이블은 **유일한 기본키(Primary Key, PK)** 를 가짐
2. **데이터 무결성(Integrity)**
    - **참조 무결성**: 외래키(FK)를 통해 테이블 간 관계를 유지
    - **도메인 무결성**: 특정 컬럼에는 정해진 데이터 타입만 저장 가능
3. **데이터 중복 최소화 (정규화, Normalization)**
    - 중복 데이터를 최소화하여 데이터베이스 크기를 줄이고, **데이터 일관성을 유지**
4. **SQL(Structured Query Language) 지원**
    - 데이터를 삽입(INSERT), 조회(SELECT), 수정(UPDATE), 삭제(DELETE) 가능
5. **트랜잭션 지원 (ACID 속성)**
    - **원자성(Atomicity)**: 트랜잭션은 **모두 실행되거나, 전혀 실행되지 않거나** 해야 함
    - **일관성(Consistency)**: 데이터가 항상 **정합성 있는 상태**를 유지해야 함
    - **고립성(Isolation)**: 여러 트랜잭션이 동시에 수행되더라도 **서로 영향을 주지 않아야 함**
    - **지속성(Durability)**: 트랜잭션이 성공적으로 수행되면 **결과가 영구적으로 반영**되어야 함

---

## **2. 복합키(Composite Key) 사용하는 상황과 예시**

### **📌 복합키란?**

- **두 개 이상의 컬럼을 조합하여 기본키(PK)로 사용하는 것**
- **단일 컬럼으로 유일성을 보장할 수 없는 경우 사용**

✅ **예제: 학생의 수강 신청 테이블**

하나의 학생(학번)이 여러 강의를 수강할 수 있고, 한 강의에 여러 학생이 등록될 수 있음 (M:N 관계).

이를 해결하기 위해 `학번`과 `강의번호`를 **복합키**로 설정.

```sql
sql
복사편집
CREATE TABLE 수강신청 (
    학번 INT,
    강의번호 INT,
    신청일 DATE,
    PRIMARY KEY (학번, 강의번호),  -- 복합키
    FOREIGN KEY (학번) REFERENCES 학생(학번),
    FOREIGN KEY (강의번호) REFERENCES 강의(강의번호)
);

```

✅ **복합키를 사용하는 이유**

- `학번`만으로는 어떤 강의를 신청했는지 알 수 없음
- `강의번호`만으로는 어떤 학생이 신청했는지 알 수 없음
- **둘을 조합하여 유일성을 보장**

---

## **3. INNER JOIN vs LEFT JOIN 차이점 (예시 포함)**

### **📌 INNER JOIN**

- **두 테이블에서 공통된 데이터만 반환**

### **📌 LEFT JOIN**

- **왼쪽 테이블의 모든 데이터 + 일치하는 오른쪽 테이블 데이터 반환** (일치하는 데이터가 없으면 NULL)

✅ **예제: 학생과 수강신청 테이블**

**학생 테이블**

| 학번 | 이름 |
| --- | --- |
| 1 | 김철수 |
| 2 | 이영희 |
| 3 | 박민수 |

**수강신청 테이블**

| 학번 | 강의번호 |
| --- | --- |
| 1 | 101 |
| 1 | 102 |
| 2 | 103 |

🔹 **INNER JOIN 실행**

```sql
sql
복사편집
SELECT 학생.학번, 학생.이름, 수강신청.강의번호
FROM 학생
INNER JOIN 수강신청 ON 학생.학번 = 수강신청.학번;

```

✅ **결과 (공통된 데이터만 반환)**

| 학번 | 이름 | 강의번호 |
| --- | --- | --- |
| 1 | 김철수 | 101 |
| 1 | 김철수 | 102 |
| 2 | 이영희 | 103 |

🔹 **LEFT JOIN 실행**

```sql
sql
복사편집
SELECT 학생.학번, 학생.이름, 수강신청.강의번호
FROM 학생
LEFT JOIN 수강신청 ON 학생.학번 = 수강신청.학번;

```

✅ **결과 (왼쪽 테이블 모든 데이터 포함, 일치하지 않는 경우 NULL)**

| 학번 | 이름 | 강의번호 |
| --- | --- | --- |
| 1 | 김철수 | 101 |
| 1 | 김철수 | 102 |
| 2 | 이영희 | 103 |
| 3 | 박민수 | NULL |

---

## **4. Materialized View vs 일반 View 차이점**

| 구분 | 일반 뷰 (View) | Materialized View |
| --- | --- | --- |
| 저장 여부 | 저장되지 않음 (쿼리만 저장) | 물리적으로 데이터를 저장 |
| 성능 | 조회 시마다 원본 테이블에서 데이터를 가져옴 | 사전 계산된 결과를 저장하여 빠름 |
| 갱신 | 항상 최신 데이터 반영 | 갱신 필요 (REFRESH) |

✅ **Materialized View 예제**

```sql
sql
복사편집
CREATE MATERIALIZED VIEW 학생_수강정보 AS
SELECT 학생.학번, 학생.이름, 수강신청.강의번호
FROM 학생
JOIN 수강신청 ON 학생.학번 = 수강신청.학번;

```

- 성능 최적화가 필요할 때 **Materialized View 사용**
- 최신 데이터가 필요하면 `REFRESH MATERIALIZED VIEW` 실행

---

## **5. VARCHAR vs CHAR 선택**

✅ **VARCHAR를 선택해야 하는 경우**

- 길이가 **가변적**인 문자열 (예: 이름, 주소)
- 공간 절약 가능 (짧은 문자열은 작은 공간 사용)

✅ **CHAR를 선택해야 하는 경우**

- **고정된 길이**의 데이터 (예: 주민등록번호, 우편번호)
- 성능이 중요한 경우 (고정 길이라 검색 속도 빠름)

예제:

- **사용자 비밀번호 해시(SHA256, 64바이트)** → `CHAR(64)`
- **이메일 주소(길이가 다름)** → `VARCHAR(100)`

---

## **6. DATETIME vs TIMESTAMP 차이**

| 구분 | DATETIME | TIMESTAMP |
| --- | --- | --- |
| 저장 크기 | 8바이트 | 4바이트 |
| 범위 | 1000-01-01 ~ 9999-12-31 | 1970-01-01 ~ 2038-01-19 |
| 자동 업데이트 | X | `DEFAULT CURRENT_TIMESTAMP` 사용 가능 |

✅ **로그 기록 저장 시 TIMESTAMP 추천 (4바이트 절약 가능)**

✅ **넓은 날짜 범위가 필요하면 DATETIME 사용**

---

## **7. GROUP BY vs HAVING 차이**

| 구분 | GROUP BY | HAVING |
| --- | --- | --- |
| 역할 | 그룹을 만듦 | 그룹 결과에서 필터링 |
| WHERE와 차이 | WHERE는 그룹핑 전 필터 | HAVING은 그룹핑 후 필터 |

✅ **예제: 과목별 평균 점수가 80점 이상인 과목 조회**

```sql
sql
복사편집
SELECT 과목, AVG(점수)
FROM 성적
GROUP BY 과목
HAVING AVG(점수) >= 80;

```

- `GROUP BY`로 과목별 그룹화
- `HAVING`으로 평균 점수 80 이상 필터링

---

📌 **정리:**

- **INNER JOIN**: 공통된 데이터만
- **LEFT JOIN**: 왼쪽 테이블 전체 + 오른쪽 일치 데이터
- **Materialized View**: 저장된 뷰, 성능 향상
- **VARCHAR vs CHAR**: 가변길이 vs 고정길이
- **DATETIME vs TIMESTAMP**: 크기 & 범위 차이
- **GROUP BY vs HAVING**: 그룹핑 vs 그룹 결과 필터링
</aside>
